import * as Kilt from '@kiltprotocol/sdk-js'
import { Response, Request, CookieOptions } from 'express'
import jwt from 'jsonwebtoken'

import { getApi } from '../utils/connection'
import { DAPP_NAME, JWT_SIGNER_SECRET } from '../config'

/**
 * Define how the Session Values are packaged.
 *
 * At the start, we only have the values from the server.
 * After verification, we also save the values that the extension (wallet) send us.
 */
export interface SessionValues {
  server: {
    dAppName: string
    dAppEncryptionKeyUri: Kilt.DidResourceUri
    challenge: string
  }
  extension?: {
    encryptedChallenge: string
    encryptionKeyUri: Kilt.DidResourceUri
    nonce: string
  }
}

// Set Cookie Options: (list of ingredients)
export const cookieOptions: CookieOptions = {
  // Indicates the number of seconds until the Cookie expires.
  maxAge: 60 * 60 * 24,
  // only send over HTTPS
  secure: true,
  // prevent cross-site request forgery attacks
  sameSite: 'strict',
  // restricts URL that can request the Cookie from the browser. '/' works for the entire domain.
  path: '/',
  // Forbids JavaScript from accessing the cookie
  httpOnly: true
}

export async function generateSessionValues(
  didDocument: Kilt.DidDocument
): Promise<SessionValues> {
  // connects to the websocket of your, in '.env', specified blockchain
  await getApi()

  // Build the EncryptionKeyUri so that the client can encrypt messages for us:
  const dAppEncryptionKeyUri =
    `${didDocument.uri}${didDocument.keyAgreement?.[0].id}` as Kilt.DidResourceUri

  if (typeof didDocument.keyAgreement === undefined) {
    throw new Error('This DID has no Key Agreement. Cannot encrypt like this.')
  }

  // Generate a challenge to ensure all messages we receive are fresh.
  // A UUID is a universally unique identifier, a 128-bit label. Here expressed as a string of a hexadecimal number.
  // It is encourage that you personalize your challenge generation.
  const challenge = Kilt.Utils.UUID.generate()

  const sessionValues = {
    server: {
      dAppName: DAPP_NAME,
      dAppEncryptionKeyUri: dAppEncryptionKeyUri,
      challenge: challenge
    }
  }

  console.log('Session Values just generated', sessionValues)

  return sessionValues
}

/**
 * Saving the session values as a JSON-Web-Token on a Cookie of the browser
 */
export async function startSession(
  request: Request,
  response: Response
): Promise<void> {
  // we use the DID-Document from the dApp fetched on server-start to generate our Session Values:
  const payload = await generateSessionValues(
    request.app.locals.dappDidDocument
  )

  // Create a Json-Web-Token:
  // set the expiration of JWT same as the Cookie
  const optionsJwt = {
    expiresIn: `${cookieOptions.maxAge} seconds`
  }
  // default to algorithm: 'HS256',
  const token = jwt.sign(payload, JWT_SIGNER_SECRET, optionsJwt)

  // Set a Cookie in the header including the JWT and our options:
  // Using 'cookie-parser' dependency:
  response.cookie('sessionJWT', token, cookieOptions)

  console.log(
    "The JSON-Web-Token with Session Values generated by the backend was saved on the 'sessionJWT'-Cookie. \n"
  )

  // send the Payload as plain text on the response, this facilitates the start of the extension session.
  response.status(200).send(payload)
}
